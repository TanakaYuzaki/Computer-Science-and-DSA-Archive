class DSU:
    def __init__(self, n):
        # Each node starts as its own parent (leader of its set)
        self.parent = [i for i in range(n+1)]
        # Track the size of each set for union by size
        self.size = [1] * (n+1)

    def find(self, v):
        """Find the leader (root) of the set containing v"""
        if self.parent[v] != v:
            # Path compression: point directly to the root
            self.parent[v] = self.find(self.parent[v])
        return self.parent[v]

    def union(self, a, b):
        """Union the sets containing a and b.
        Returns True if merged, False if already in the same set (cycle)."""
        a = self.find(a)
        b = self.find(b)
        if a == b:
            return False  # already connected â†’ would form a cycle
        # Union by size: attach smaller tree under larger
        if self.size[a] < self.size[b]:
            a, b = b, a
        self.parent[b] = a
        self.size[a] += self.size[b]
        return True
    
# Suppose we have 5 cities
dsu = DSU(5)

edges = [(1,2), (2,3), (3,4), (4,5)]

for u, v in edges:
    if not dsu.union(u, v):
        print(f"Edge {u}-{v} is redundant (forms a cycle)")
    else:
        print(f"Edge {u}-{v} successfully connected")

# Check connectivity
leaders = {dsu.find(i) for i in range(1, 6)}
if len(leaders) == 1:
    print("All cities are connected (it's a tree).")
else:
    print(f"There are {len(leaders)} components, not fully connected.")
print(dsu.parent)
